#!/usr/bin/python
"""Command line tool for building a standalone storm jar ready to be submitted
to a storm cluster. It is also able to staisfy all the dependencies needed by
the source code if listed in a special requirements.txt file. Virtualenv and
pip install are used for this task.

Args:
    TOPOLOGY_DIRECTORY - the directory where all the topology source files,
        the YAML file describing the topology and the requirements.txt file
        must to be placed.

The script will validate the topology in order to ensure the presence of
the aforementioned YAML file and also of the requirements.txt file, in case
a virtualenv should be used. See _validate_tolopology() for detailed info.

The output jar is built from a common base jar included in the pyleus package,
if nothing different is specified, and will be named as the topology directory.

NOTE: The names used for the YAML file and for the virtualenv CANNOT be changed
without modifying accordingly the java code in charge of parsing the file and
starting every bolt or spout.
"""

import optparse
import glob
import re
import tempfile
import os
import shutil
import subprocess
import sys
import zipfile


BASE_JAR_PATH = "minimal.jar"
RESOURCES_PATH = "resources/"
YAML_FILENAME = "pyleus_topology.yaml"
REQUIREMENTS_FILENAME = "requirements.txt"
VIRTUALENV = "pyleus_venv"

PROG = os.path.basename(sys.argv[0])
PYLEUS_ERROR_FMT = "{0}: error: {1}"


class PyleusError(Exception):
    """Base class for pyleus specific exceptions"""
    def __str__(self):
        return "[{0}] {1}".format(type(self).__name__,
                ", ".join(str(i) for i in self.args))


class JarError(PyleusError): pass
class TopologyError(PyleusError): pass
class InvalidTopologyError(TopologyError): pass
class DependenciesError(TopologyError): pass


def _open_jar(base_jar):
    """Open the base jar file.
    Jar files are treated as zip files.
    """
    if not os.path.exists(base_jar):
        raise JarError("Base jar not found")

    if not zipfile.is_zipfile(base_jar):
        raise JarError("Base jar is not a jar file")

    zip_file = zipfile.ZipFile(base_jar, "r")

    return zip_file


def _validate_topology(topology_dir, opts):
    """Validate the topology in order to ensure the presence of the aforementioned
    YAML file and of the requirements.txt file in case a virtualenv should be used.

    In the latter case, look for any already existing file matching the name of
    the virtualenv, in order to avoid name clashes.

    If neither of the options concerning the use of a virtualend are specified,
    deduce if a virtualenv is needed or not from the presence of the
    requirements.txt file.

    Exceptions with a meaningful message are raised in case of invalid topologies.
    """
    if not os.path.exists(topology_dir):
        raise TopologyError("Topology directory not found: {0}".format(
            topology_dir))

    if not os.path.isdir(topology_dir):
        raise TopologyError("Topology directory is not a directory: {0}".format(
            topology_dir))

    yaml = os.path.join(topology_dir, YAML_FILENAME)
    if not os.path.isfile(yaml):
        raise InvalidTopologyError("Topology YAML not found: {0}".format(yaml))

    req = os.path.join(topology_dir, REQUIREMENTS_FILENAME)
    if opts.use_virtualenv is None:
        opts.use_virtualenv = False if not os.path.isfile(req) else True

    if opts.use_virtualenv is False:
        return yaml, None

    if opts.use_virtualenv is True:
        if not os.path.isfile(req):
            raise InvalidTopologyError("{0} file not found".format(
                REQUIREMENTS_FILENAME))

        venv = os.path.exists(os.path.join(topology_dir, VIRTUALENV))
        if venv:
            raise InvalidTopologyError("Topology directory must not contain a "
                "file named {0}".format(VIRTUALENV))
        return yaml, req


def _virtualenv_pip_install(tmp_dir, req, **kwargs):
    """Create a virtualenv with the specified options and run
    pip install on the requirements.txt file in the topology directory.

    Options:
        system-site-packages - creating the virtualenv with this flag,
        pip will not download and install in the virtualenv all the
        dependencies already installed system-wide.
        index-url - allow to specify the URL of the Python Package Index.
        pip-log - a verbose log generated by pip install
    """
    virtualenv_cmd = ["virtualenv", VIRTUALENV]

    if kwargs.get("system") is True:
        virtualenv_cmd.append("--system-site-packages")

    pip_cmd = [os.path.join(VIRTUALENV, "bin", "pip"), "install", "-r", req]

    if kwargs.get("index_url") is not None:
        pip_cmd += ["-i", kwargs["index_url"]]

    if kwargs.get("pip_log") is not None:
        pip_cmd += ["--log", kwargs["pip_log"]]

    out_stream = None
    if kwargs.get("verbose") is False:
        out_stream = open(os.devnull, "w")

    ret_code = subprocess.call(virtualenv_cmd, cwd=tmp_dir, stdout=out_stream,
        stderr=subprocess.STDOUT)
    if ret_code != 0:
        raise DependenciesError("Failed to install dependencies for this "
            "topology. Failed to create virtualenv.")

    ret_code = subprocess.call(pip_cmd, cwd=tmp_dir, stdout=out_stream,
        stderr=subprocess.STDOUT)
    if ret_code != 0:
        raise DependenciesError("Failed to install dependencies for this "
            "topology. Run with --verbose for detailed info.")


def _copy_dir_content(src, dst, excluded):
    """Copy the content of a directory excluding the paths
    matching the patterns in the excluded list.

    Filtering is applied only at the top level of the directory.

    This functions is used instead of shutil.copytree() because
    the latter always creates a top level directory, while only
    the content need to be copied in this case..
    """
    # From all content
    content = set(glob.glob(os.path.join(src, "*")))
    # Exclude everything matching the patterns specified in excluded
    if excluded:
        content -= set([q for x in excluded for q in
            glob.glob(os.path.join(src, x))])
    # Then exclude links
    content = [t for t in content if not os.path.islink(t)]

    for t in content:
        if os.path.isdir(t):
            shutil.copytree(t, os.path.join(dst, os.path.basename(t)))
        else:
            shutil.copy2(os.path.join(src, t), dst)


def _zip_dir(src, arc):
    """Build a zip archive from the specified src.

    NOTE: If the archive already exists, files will be simply
    added to it, but the original archive will not be replaced.
    At the current state, this script enforce the creation of
    a brand new zip archive each time is run, otehrwise it will
    raise an exception.
    """
    src_re = re.compile(src + "/*")
    for root, dirs, files in os.walk(src):
        # hack for copying everithing but the top directory
        prefix = re.sub(src_re, "", root)
        for f in files:
            # zipfile creates directories if missing
            arc.write(os.path.join(root, f), os.path.join(prefix, f),
                    zipfile.ZIP_DEFLATED)


def _pack_jar(tmp_dir, output_jar):
    """Build a jar from the temporary directory."""
    if os.path.exists(output_jar):
        raise JarError("Output jar already exist: {0}".format(output_jar))

    zf = zipfile.ZipFile(output_jar, "w")
    try:
        _zip_dir(tmp_dir, zf)
    finally:
        zf.close()


def _inject(topology_dir, base_jar, output_jar, zip_file, tmp_dir, options):
    """Validate the topology, copy all the topology source files in the tmp directory,
    install dependencies if necessary and create the final standalone jar ready to be
    shippped.
    """
    # Extract pyleus base jar content in a tmp dir
    zip_file.extractall(tmp_dir)

    # Validate topolgy and return requirements and yaml file path
    yaml, req = _validate_topology(topology_dir, options)

    # Copy yaml into its directory
    shutil.copy2(yaml, os.path.join(tmp_dir, RESOURCES_PATH))

    # Add the topology directory skipping yaml and requirements
    topo_exclude = [yaml]
    if req is not None:
        topo_exclude.append(req)
    _copy_dir_content(topology_dir, os.path.join(tmp_dir, RESOURCES_PATH),
            topo_exclude)

    # Virtualenv + pip install used to install dependencies listed in
    # requirements.txt
    if options.use_virtualenv:
        _virtualenv_pip_install(tmp_dir=os.path.join(tmp_dir, RESOURCES_PATH),
                req=req,
                system=options.system,
                index_url=options.index_url,
                pip_log=options.pip_log,
                verbose=options.verbose)

    # Pack the tmp directory into a jar
    _pack_jar(tmp_dir, output_jar)


def _build_output_path(output_arg, topology_dir):
    """Return the absolute path of the output jar file.

    Default basename:
        TOPOLOGY_DIRECTORY.jar
    """
    if output_arg is not None:
        output_jar = os.path.abspath(output_arg)
    else:
        output_jar = os.path.abspath(os.path.basename(topology_dir) + ".jar")
    return output_jar


def main():
    """Define the command line interface, convert avery path or argument in its
    absolute form, open the base jar file and creates the tmp directory where
    where everything will be copied before injecting topology source files.

    All pyleus specific exceptions are caught here.
    """
    parser = optparse.OptionParser(
            usage="usage: %prog [options] TOPOLOGY_DIRECTORY",
            description="Build up a storm jar from a topology source directory")
    parser.add_option("-b", "--base", dest="base_jar", default=BASE_JAR_PATH,
            help="pyleus base jar file path")
    parser.add_option("-o", "--out", dest="output_jar",
            help="path of the jar file that will contain"
            " all the dependencies and the resources")
    parser.add_option("--use-virtualenv", dest="use_virtualenv",
            default=None, action="store_true",
            help="use virtualenv and pip install for dependencies."
            " Your TOPOLOGY_DIRECTORY must contain a file named {0}"
            .format(REQUIREMENTS_FILENAME))
    parser.add_option("--no-use-virtualenv",
            dest="use_virtualenv", action="store_false",
            help="do not use virtualenv and pip for dependencies")
    parser.add_option("-i", "--index-url", dest="index_url",
            help="base URL of Python Package Index used by pip"
            " (default https://pypi.python.org/simple/)")
    parser.add_option("-s", "--system-packages", dest="system",
            default=False, action="store_true",
            help="do not install packages already present in your system")
    parser.add_option("--log", dest="pip_log", help="log location for pip")
    parser.add_option("-v", "--verbose", dest="verbose",
            default=False, action="store_true",
            help="verbose")
    options, args = parser.parse_args()

    if len(args) != 1:
        parser.error("incorrect number of arguments")

    # Transform each path in its absolute version
    topology_dir = os.path.abspath(args[0])
    base_jar = os.path.abspath(options.base_jar)
    output_jar = _build_output_path(options.output_jar, topology_dir)
    if options.pip_log is not None:
        options.pip_log = os.path.abspath(options.pip_log)

    # Check for output path existence for early failure
    if os.path.exists(output_jar):
        e = JarError("Output jar already exist: {0}".format(output_jar))
        sys.exit(PYLEUS_ERROR_FMT.format(PROG, str(e)))

    try:
        # Open the base jar as a zip
        zip_file = _open_jar(base_jar)
    except PyleusError as e:
        sys.exit(PYLEUS_ERROR_FMT.format(PROG, str(e)))

    try:
        # Everything will be copied in a tmp directory
        tmp_dir = tempfile.mkdtemp()
        try:
            _inject(topology_dir, base_jar, output_jar,
                    zip_file, tmp_dir, options)
        except PyleusError as e:
            sys.exit(PYLEUS_ERROR_FMT.format(PROG, str(e)))
        finally:
            shutil.rmtree(tmp_dir)
    finally:
        zip_file.close()


if __name__ == "__main__":
    main()
